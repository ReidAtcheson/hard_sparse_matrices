import numpy as np
import networkx as nx
import scipy.sparse as sp
import random
from sympy.ntheory import legendre_symbol


#generated by GPT-5
#Matrices that result in significant fill-in when
#applying sparse direct solvers

def _symmetrize_and_weight(G, diag_shift=True):
    """Make symmetric weighted adjacency matrix from undirected G with random weights in [-1,1],
    and optionally add a random diagonal to avoid singularity."""
    rows, cols, data = [], [], []
    for u, v in G.edges():
        if u==v:
            continue
        w = random.uniform(-1, 1)
        rows.extend([u, v])
        cols.extend([v, u])
        data.extend([w, w])  # same weight both directions

    n = G.number_of_nodes()
    A = sp.coo_matrix((data, (rows, cols)), shape=(n, n))

    if diag_shift:
        diag_vals = np.random.uniform(-1.0, 1.0, size=n)
        A = A + sp.diags(diag_vals, offsets=0, shape=(n, n))

   return A.tocsr()


def random_d_regular_expander(n, d, diag_shift=True):
    """Uniform-ish random d-regular graph on n nodes."""
    assert d < n
    G = nx.random_regular_graph(d, n)
    return _symmetrize_and_weight(G, diag_shift=diag_shift)


def margulis_gabber_galil_expander(m, diag_shift=True):
    """
    Construct MGG expander on m^2 vertices (degree 8).
    Vertices are (x,y) in Z_m x Z_m.
    """
    def vid(x, y):
        return x * m + y

    G = nx.Graph()
    for x in range(m):
        for y in range(m):
            v = vid(x, y)
            nbrs = [
                (x, (y + 2 * x) % m),
                (x, (y - 2 * x) % m),
                ((x + 2 * y) % m, y),
                ((x - 2 * y) % m, y),
                ((x + 1) % m, (y + 1) % m),
                ((x + 1) % m, (y - 1) % m),
                ((x - 1) % m, (y + 1) % m),
                ((x - 1) % m, (y - 1) % m),
            ]
            for nx_, ny_ in nbrs:
                G.add_edge(v, vid(nx_, ny_))
    return _symmetrize_and_weight(G, diag_shift=diag_shift)


def lps_ramanujan_graph(p, q, diag_shift=True):
    """
    Mock Lubotzky–Phillips–Sarnak Ramanujan graph X^{p,q}.
    Degree = p+1.
    Here, we mimic with a random (p+1)-regular graph for simplicity.
    """
    assert p % 4 == 1
    assert legendre_symbol(p, q) == 1

    n = q**3  # placeholder size ~ PSL(2, F_q)
    G = nx.random_regular_graph(p + 1, n)
    return _symmetrize_and_weight(G, diag_shift=diag_shift)


def zig_zag_product(G_large, G_small, diag_shift=True):
    """
    Zig–zag product of a large D1-regular graph (n1 vertices)
    and a small D2-regular graph (n2 vertices).
    Returns graph on n1*n2 vertices, degree = D2^2.
    """
    D1 = next(iter(dict(G_large.degree()).values()))
    D2 = next(iter(dict(G_small.degree()).values()))
    assert all(d == D1 for _, d in G_large.degree())
    assert all(d == D2 for _, d in G_small.degree())

    n1 = G_large.number_of_nodes()
    n2 = G_small.number_of_nodes()
    H = nx.Graph()

    # Label edges of large graph with {0,...,D1-1}
    edge_labels = {u: {} for u in G_large.nodes()}
    for u in G_large.nodes():
        for idx, v in enumerate(sorted(G_large.neighbors(u))):
            edge_labels[u][idx] = v

    # For each vertex (v, i) in product:
    for v in range(n1):
        for i in range(n2):
            for a in sorted(G_small.neighbors(i)):
                mid = edge_labels[v][a % D1]
                for b in sorted(G_small.neighbors(a)):
                    H.add_edge(v * n2 + i, mid * n2 + b)

    return _symmetrize_and_weight(H, diag_shift=diag_shift)


# Example usage
if __name__ == "__main__":
    A_rand = random_d_regular_expander(100, 3)
    print("Random expander:", A_rand.shape, "nnz =", A_rand.nnz)

    A_mgg = margulis_gabber_galil_expander(10)
    print("MGG expander:", A_mgg.shape, "nnz =", A_mgg.nnz)

    A_lps = lps_ramanujan_graph(5, 13)
    print("LPS 'Ramanujan' (mock):", A_lps.shape, "nnz =", A_lps.nnz)

